/* eslint-disable import/no-extraneous-dependencies, no-await-in-loop, no-restricted-syntax */

import { promises as fs } from 'fs'
import { join } from 'path'
import stripJsonComments from 'strip-json-comments'

const DIRECTORY_PATH = join(import.meta.url, '../../../backend/src/main/resources/db/testdata').replace('file:', '')

function setJsonbSqlPropsToNull(obj) {
  const processObject = currentObj => {
    const processedObj = Array.isArray(currentObj) ? [] : {}
    Object.entries(currentObj).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        processedObj[key] = value.map(valueItem => processObject(valueItem))
      } else if (typeof value === 'object' && value !== null) {
        processedObj[key] = processObject(value)
      } else {
        // Temporarily set :jsonb > :sql properties to null in the `INSERT` statement
        // so that they can be updated with subsequent `UPDATE` statements
        processedObj[key] = key.endsWith(':sql') ? null : value
      }
    })

    return processedObj
  }

  return `'${JSON.stringify(processObject(obj)).replace(/:sql"/g, '"').replace(/'/g, "''")}'`
}

function generateInsertStatement(row, table) {
  const sqlColumns = []
  const sqlValues = []

  const rowAsKeyValuePairs = Object.entries(row)

  for (const [key, value] of rowAsKeyValuePairs) {
    const sqlColumn = key.replace(/:(jsonb|sql)$/, '')
    if (key.endsWith(':jsonb')) {
      const sqlValue = setJsonbSqlPropsToNull(value)

      sqlColumns.push(sqlColumn)
      sqlValues.push(sqlValue)
    } else {
      const processedValue =
        // eslint-disable-next-line no-nested-ternary
        value === null
          ? 'null'
          : typeof value !== 'string' || key.endsWith(':sql')
          ? value
          : `'${value.replace(/'/g, "''")}'`

      sqlColumns.push(sqlColumn)
      sqlValues.push(processedValue)
    }
  }

  return `INSERT INTO ${table} (${sqlColumns.join(', ')}) VALUES (${sqlValues.join(', ')});`
}

function generateUpdateStatements(row, table) {
  const updates = []

  const processUpdates = (obj, path = []) => {
    Object.entries(obj).forEach(([key, value]) => {
      const currentPath = [...path, key.replace(/:sql$/, '')]
      if (key.endsWith(':sql')) {
        updates.push(
          `UPDATE ${table} SET value = JSONB_SET(value, '{${currentPath.join(
            ','
          )}}', TO_JSONB(${value}), true) WHERE id = ${row.id};`
        )
      } else if (typeof value === 'object' && value !== null) {
        processUpdates(value, currentPath)
      }
    })
  }

  Object.entries(row).forEach(([key, value]) => {
    if (key.endsWith(':jsonb')) {
      processUpdates(value)
    }
  })

  return updates
}

console.info(`
######   ######   ######   ######           ######    #####    ######   #####
  ##    ##       ##          ##             ##   ##  ##   ##     ##    ##   ##
  ##    ## ###    #####      ##             ##   ##  ## ####     ##    ## ####
  ##    ##            ##     ##             ##   ##  ##   ##     ##    ##   ##
  ##     ######  ######      ##             ## ###   ##   ##     ##    ##   ##
`)

const jsonFiles = (await fs.readdir(DIRECTORY_PATH)).filter(file => file.endsWith('.jsonc'))
for (const file of jsonFiles) {
  const jsonFilePath = join(DIRECTORY_PATH, file)
  const outputSqlFilePath = jsonFilePath.replace('.jsonc', '.sql')
  const jsonSource = await fs.readFile(jsonFilePath, 'utf8')
  const jsonSourceAsObject = JSON.parse(stripJsonComments(jsonSource))

  const dataTables = Array.isArray(jsonSourceAsObject) ? jsonSourceAsObject : [jsonSourceAsObject]
  const sqlStatementBlocks = dataTables
    .map(dataTable => {
      const { data: rows, table } = dataTable

      return rows.map(row => {
        const insertStatement = generateInsertStatement(row, table)
        const updateStatements = generateUpdateStatements(row, table)

        return [insertStatement, ...updateStatements, ''].join('\n')
      })
    })
    .flat()

  const sqlSource = [
    `-- /!\\ This file is automatically generated by a local script.`,
    `-- Do NOT update it directly, update the associated .jsonc file.`,
    '',
    ...sqlStatementBlocks
  ].join('\n')
  await fs.writeFile(outputSqlFilePath, sqlSource, 'utf8')
  console.info(`[Test Data Generator] SQL Test Data file generated at ${outputSqlFilePath}`)
}

console.info()
